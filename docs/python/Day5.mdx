---
sidebar_position: 6
---

# Functions and Creativity (Day 5)

## Creating Efficient Functions: 
Boosting Code Reusability and Efficiency
Welcome to Day 5 of our coding journey! Today, we're diving into the world of functions â€“ the building blocks of efficient and organized code. Functions allow us to encapsulate code into reusable units, making our programs more modular and easier to manage.

## Why Functions Matter:

**Code Reusability:** Functions enable us to write code once and use it multiple times, reducing redundancy and making maintenance a breeze.

**Modularity:** By breaking down complex tasks into smaller functions, we create a modular structure that's easier to understand and debug.

**Efficiency:** Functions improve code efficiency by isolating specific tasks and optimizing their execution.

### Creating and Using Functions:

```python
# Defining a simple function
def greet(name):
    return f"Hello, {name}!"

# Calling the function
message = greet("AdamsGeeky")
print(message)

```

# List Comprehensions:

Embracing Concise Coding Imagine you have a magical wand that can create lists with just one wave. That's the magic of list comprehensions! They offer a concise way to create and manipulate lists, making your code elegant and efficient.

## Why List Comprehensions Matter:

**Concise Syntax**: List comprehensions allow you to express complex operations on lists in a single line of code.

**Readability:** Despite their brevity, list comprehensions can be more readable than traditional loops.

**Performance:** List comprehensions can often outperform traditional loops, improving code execution speed.

### Using List Comprehensions:
```python
# Creating a list of squares using a loop
squares = []
for x in range(1, 6):
    squares.append(x ** 2)

# Creating the same list using a list comprehension
squares_comp = [x ** 2 for x in range(1, 6)]
```

# Empowerment through Modules: 
Managing Complexity Just like a toolkit with neatly organized compartments, modules help us keep our codebase organized and scalable. Modules allow us to group related functions, classes, and variables together, promoting a clean and maintainable code structure.

## Why Modules Matter:

**Code Organization**: Modules keep related code together, making it easier to locate and manage.

**Avoiding Name Conflicts**: Modules prevent naming clashes by providing a separate namespace for variables and functions.

**Reusability:** You can reuse modules across different projects, saving time and effort.

## Creating and Using Modules:
```python
# Creating a module (module.py)
def greet(name):
    return f"Hello, {name}!"
    
# Using the module in another file
import module
message = module.greet("Bob")
print(message)
```

# Project Exploration: Applying Your Knowledge

Now, let's put everything you've learned into practice. In today's project, we'll collaboratively create a weather app that not only displays temperatures but also incorporates functions for efficient code organization, list comprehensions for concise data processing, and modules to manage different aspects of the app.

```python
# Weather App with Functions, List Comprehensions, and Modules

import temperatures_module

# Getting temperatures
temperatures = temperatures_module.get_temperatures()

# Function to calculate average temperature
def calculate_average(temps):
    total = sum(temps)
    return total / len(temps)

average_temp = calculate_average(temperatures)
print("Average Temperature:", average_temp)

# List comprehension to filter hot days
hot_days = [day for day in temperatures if day > 30]
print("Hot Days:", hot_days)
```

# Here's the continuation of the online marketplace project with the new features

```python
# Online Marketplace with New Features 

# Set for product categories
product_categories = {"Electronics", "Clothing", "Books", "Beauty"}

# Dictionary for product information
products = {
    101: {"name": "Smartphone", "price": 499.99, "availability": True},
    102: {"name": "T-shirt", "price": 19.99, "availability": False},
    # ... other products
}

# User Authentication
users = {
    "namehere": "password123",
    "username": "securepass"
}

def authenticate(username, password):
    if username in users and users[username] == password:
        return True
    return False

# Wishlist Feature
def create_wishlist():
    return set()

def add_to_wishlist(wishlist, product_id):
    wishlist.add(product_id)

def remove_from_wishlist(wishlist, product_id):
    wishlist.discard(product_id)

# Filtering and Sorting
def filter_by_category(category):
    filtered_products = {product_id: product_info for product_id, product_info in products.items() if category in product_categories}
    return filtered_products

def sort_by_price_asc():
    sorted_products = sorted(products.items(), key=lambda item: item[1]["price"])
    return dict(sorted_products)

def sort_by_price_desc():
    sorted_products = sorted(products.items(), key=lambda item: item[1]["price"], reverse=True)
    return dict(sorted_products)

# Sample Usage
if __name__ == "__main__":
    # Simulating user authentication
    username = input("Enter your username: ")
    password = input("Enter your password: ")
    if authenticate(username, password):
        print("Authentication successful!")
        user_wishlist = create_wishlist()

        # Simulating wishlist usage
        add_to_wishlist(user_wishlist, 101)
        add_to_wishlist(user_wishlist, 102)

        # Simulating filtering and sorting
        filtered_electronics = filter_by_category("Electronics")
        sorted_products_asc = sort_by_price_asc()
        sorted_products_desc = sort_by_price_desc()

        print("Filtered Electronics:", filtered_electronics)
        print("Sorted Products (Ascending):", sorted_products_asc)
        print("Sorted Products (Descending):", sorted_products_desc)
    else:
        print("Authentication failed.")
```

# Here's what you can expect as the output of the code:

**If the user authentication is successful**

```bash
Enter your username: username
Enter your password: password123
Authentication successful!
Filtered Electronics: {101: {'name': 'Smartphone', 'price': 499.99, 'availability': True}}
Sorted Products (Ascending): {102: {'name': 'T-shirt', 'price': 19.99, 'availability': False}, 101: {'name': 'Smartphone', 'price': 499.99, 'availability': True}}
Sorted Products (Descending): {101: {'name': 'Smartphone', 'price': 499.99, 'availability': True}, 102: {'name': 'T-shirt', 'price': 19.99, 'availability': False}}

**If the user authentication fails**
```bash
Enter your username: userName
Enter your password: hacker123
Authentication failed.
```
Keep in mind that the actual output may vary slightly depending on the data entered during the simulation (such as adding products to the wishlist or using different usernames and passwords).

# code Explanation
let's break down the code step by step:

```python
# Online Marketplace with New Features 

# Set for product categories
product_categories = {"Electronics", "Clothing", "Books", "Beauty"}

# Dictionary for product information
products = {
    101: {"name": "Smartphone", "price": 499.99, "availability": True},
    102: {"name": "T-shirt", "price": 19.99, "availability": False},
    # ... other products
}
```
In this section, we define the initial product categories as a set **product_categories** and the product information as a **dictionary products**. The dictionary contains product IDs **(keys)** mapped to dictionaries with product details **(values)**.

```python
# User Authentication
users = {
   "namehere": "password123",
    "username": "securepass"
}

def authenticate(username, password):
    if username in users and users[username] == password:
        return True
    return False
```

The **users dictionary** stores **usernames as keys** and corresponding **passwords as values**.
The **authenticate function** takes a username and password as **arguments** and checks if the provided credentials match those in the users dictionary.

```python
# Wishlist Feature
def create_wishlist():
    return set()

def add_to_wishlist(wishlist, product_id):
    wishlist.add(product_id)

def remove_from_wishlist(wishlist, product_id):
    wishlist.discard(product_id)
```
The **create_wishlist** function returns an empty set, simulating the creation of a user's wishlist. **add_to_wishlist** and **remove_from_wishlist** functions are used to add and remove **product IDs** from the wishlist.

```python
# Filtering and Sorting
def filter_by_category(category):
    filtered_products = {product_id: product_info for product_id, product_info in products.items() if category in product_categories}
    return filtered_products

def sort_by_price_asc():
    sorted_products = sorted(products.items(), key=lambda item: item[1]["price"])
    return dict(sorted_products)

def sort_by_price_desc():
    sorted_products = sorted(products.items(), key=lambda item: item[1]["price"], reverse=True)
    return dict(sorted_products)
```
The **filter_by_category** function takes a category as an argument and filters the products dictionary to include only products within that category. The **sort_by_price_asc** and **sort_by_price_desc** functions sort the products by price in ascending and descending order, respectively.

```python
# Sample Usage
if __name__ == "__main__":
    # Simulating user authentication
    username = input("Enter your username: ")
    password = input("Enter your password: ")
    if authenticate(username, password):
        print("Authentication successful!")
        user_wishlist = create_wishlist()

        # Simulating wishlist usage
        add_to_wishlist(user_wishlist, 101)
        add_to_wishlist(user_wishlist, 102)

        # Simulating filtering and sorting
        filtered_electronics = filter_by_category("Electronics")
        sorted_products_asc = sort_by_price_asc()
        sorted_products_desc = sort_by_price_desc()

        print("Filtered Electronics:", filtered_electronics)
        print("Sorted Products (Ascending):", sorted_products_asc)
        print("Sorted Products (Descending):", sorted_products_desc)
    else:
        print("Authentication failed.")
```

In this final section, we simulate user authentication by prompting the user for a username and password. If the authentication is successful, we create a user's wishlist, add products to the wishlist, and then demonstrate filtering and sorting functionalities.


The output will depend on the input provided during the simulation. **If authentication is successful**, the filtered electronics, sorted products in ascending and descending order will be displayed. If authentication fails, the code will indicate that authentication failed.

Remember that this code snippet is a simulation and doesn't include the actual implementation of user interaction. It's meant to demonstrate the functionality of **sets**, **dictionaries**, and **functions** 

# ðŸŒŸ Unlocking Creativity with Knowledge
remember that functions, list comprehensions, and modules are powerful tools that empower your coding creativity. You now have the skills to create modular, efficient, and elegant code that can tackle diverse challenges.

In our upcoming session, we'll dive even deeper into **Object-Oriented Programming** (OOP). OOP is a powerful paradigm that allows us to model real-world concepts and relationships in our code. By using classes and objects, we can create more organized, modular, and reusable code.